<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<!-- REQUIRED META DATA -->
	<title>Helix Gallery V4</title>
	<meta name="description" content="Infinite spiral gallery with server-side thumbnail optimization">
	<meta name="page:icon" content="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/svgs/solid/infinity.svg">
	<meta name="page:color" content="#4f46e5">

	<!-- Tailwind CSS -->
	<script src="https://cdn.tailwindcss.com"></script>
	<script>
		tailwind.config = {
			theme: {
				extend: {
					colors: {
						brand: {
							DEFAULT: '#4f46e5',
							dark: '#312e81',
							accent: '#818cf8',
						},
						ui: {
							bg: '#050505',
							panel: '#0f0f12',
							border: '#1f1f26'
						}
					},
					animation: {
						'fade-in': 'fadeIn 0.2s ease-out',
						'slide-up': 'slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1)',
						'slide-in-bottom': 'slideInBottom 0.3s cubic-bezier(0.16, 1, 0.3, 1)',
					},
					keyframes: {
						fadeIn: {
							'0%': { opacity: '0' },
							'100%': { opacity: '1' },
						},
						slideUp: {
							'0%': { transform: 'translateY(20px)', opacity: '0' },
							'100%': { transform: 'translateY(0)', opacity: '1' },
						},
						slideInBottom: {
							'0%': { transform: 'translateY(100%)' },
							'100%': { transform: 'translateY(0)' },
						}
					}
				}
			}
		}
	</script>

	<!-- Icons -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

	<style>
		body,
		html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			background-color: #050505;
			touch-action: none;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			color: #e0e7ff;
			-webkit-font-smoothing: antialiased;
			overscroll-behavior: none;
		}

		#canvas-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 1;
		}

		.ui-layer {
			position: absolute;
			z-index: 10;
			pointer-events: none;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
		}

		.pointer-events-auto {
			pointer-events: auto;
		}

		/* Custom Scrollbar */
		.custom-scroll::-webkit-scrollbar {
			width: 4px;
		}

		.custom-scroll::-webkit-scrollbar-track {
			background: transparent;
		}

		.custom-scroll::-webkit-scrollbar-thumb {
			background: #333;
			border-radius: 2px;
		}

		.custom-scroll::-webkit-scrollbar-thumb:hover {
			background: #4f46e5;
		}

		.glass-panel {
			background: rgba(15, 15, 18, 0.96);
			backdrop-filter: blur(16px);
			border: 1px solid rgba(255, 255, 255, 0.08);
			box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
		}

		/* Common Glass Button Style */
		.btn-glass {
			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(8px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: rgba(255, 255, 255, 0.9);
			transition: all 0.2s ease;
		}

		.btn-glass:hover {
			background: rgba(255, 255, 255, 0.1);
			color: #fff;
		}

		.btn-glass:active {
			transform: scale(0.95);
		}

		.loader {
			border: 2px solid rgba(255, 255, 255, 0.1);
			border-left-color: #4f46e5;
			border-radius: 50%;
			width: 24px;
			height: 24px;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}

		/* Detail Image Manipulation */
		#detail-view-container {
			touch-action: none;
			overflow: hidden;
			cursor: grab;
		}

		#detail-view-container:active {
			cursor: grabbing;
		}

		#detail-image-wrapper {
			will-change: transform;
			transform-origin: center center;
		}
	</style>
</head>

<body>

	<!-- Main Gallery Canvas -->
	<div id="canvas-container">
		<canvas id="galleryCanvas"></canvas>
	</div>

	<!-- Main UI Overlay -->
	<div class="ui-layer flex flex-col justify-between p-4 safe-area-inset">
		<!-- Header -->
		<div class="flex justify-between items-start pointer-events-auto">
			<!-- Header Background Added -->
			<div class="btn-glass rounded-2xl p-3 px-4 flex flex-col justify-center shadow-lg select-none">
				<h1 class="text-xl font-black tracking-tighter text-white drop-shadow-md leading-none">
					HELIX
				</h1>
				<div id="status-indicator"
					class="text-[9px] text-gray-400 font-mono font-bold tracking-widest mt-1 leading-none">
					SYSTEM READY</div>
			</div>

			<button onclick="app.resetView()"
				class="w-12 h-12 btn-glass rounded-full flex items-center justify-center shadow-lg">
				<i class="fa-solid fa-compress text-sm"></i>
			</button>
		</div>

		<!-- Search FAB (Modified to Glass) -->
		<div class="absolute bottom-8 right-6 pointer-events-auto">
			<button onclick="ui.openSearchModal()"
				class="group w-16 h-16 btn-glass rounded-full shadow-[0_8px_30px_rgba(0,0,0,0.5)] flex items-center justify-center transition-all transform hover:scale-105 active:scale-90 border-brand/30">
				<i
					class="fa-solid fa-magnifying-glass text-xl text-brand-accent group-hover:text-white group-hover:rotate-90 transition-all duration-300"></i>
			</button>
		</div>
	</div>

	<!-- Search Modal -->
	<div id="search-modal"
		class="hidden fixed inset-0 z-50 bg-black/60 backdrop-blur-sm animate-fade-in flex items-end sm:items-center justify-center pointer-events-auto">
		<div
			class="glass-panel w-full sm:w-[480px] h-[85vh] sm:h-auto sm:max-h-[80vh] rounded-t-3xl sm:rounded-3xl flex flex-col animate-slide-up overflow-hidden shadow-2xl">

			<div class="p-5 border-b border-ui-border flex justify-between items-center shrink-0 bg-black/20">
				<h2 class="text-lg font-bold text-white flex items-center gap-2">
					<span class="w-1 h-5 bg-brand rounded-full"></span>
					Search Filter
				</h2>
				<button onclick="ui.closeSearchModal()"
					class="w-8 h-8 flex items-center justify-center rounded-full hover:bg-white/10 text-gray-400 hover:text-white transition-colors">
					<i class="fa-solid fa-xmark"></i>
				</button>
			</div>

			<div class="flex-1 overflow-y-auto custom-scroll p-5 space-y-6">
				<!-- Text Query with Autocomplete -->
				<div class="space-y-2 relative">
					<label class="text-xs font-bold text-gray-500 uppercase tracking-wider">Keywords</label>
					<div class="relative group">
						<input type="text" id="search-text" placeholder="Concept, tag, style..." autocomplete="off"
							class="w-full bg-black/40 border border-ui-border rounded-xl py-3 pl-11 pr-4 text-white focus:outline-none focus:border-brand focus:ring-1 focus:ring-brand transition-all placeholder-gray-600">
						<i
							class="fa-solid fa-hashtag absolute left-4 top-3.5 text-gray-500 group-focus-within:text-brand transition-colors"></i>
					</div>
					<!-- Autocomplete Dropdown -->
					<div id="search-suggestions"
						class="hidden absolute top-full left-0 w-full mt-2 bg-ui-panel border border-ui-border rounded-xl shadow-2xl z-50 max-h-48 overflow-y-auto custom-scroll">
						<!-- Suggestions injected via JS -->
					</div>
				</div>

				<!-- Image Refs -->
				<div class="space-y-2">
					<div class="flex justify-between items-center">
						<label class="text-xs font-bold text-gray-500 uppercase tracking-wider">Image Guidance</label>
						<label
							class="text-xs font-bold text-brand-accent cursor-pointer hover:text-white transition-colors py-1 px-2 rounded hover:bg-white/5">
							<i class="fa-solid fa-plus mr-1"></i>UPLOAD
							<input type="file" multiple accept="image/*" class="hidden"
								onchange="searchManager.handleFileUpload(this)">
						</label>
					</div>

					<div id="reference-list" class="space-y-3 min-h-[60px]">
						<div id="empty-refs"
							class="flex flex-col items-center justify-center py-8 border border-dashed border-ui-border rounded-xl text-gray-600 gap-2 bg-black/20">
							<i class="fa-regular fa-image text-2xl opacity-50"></i>
							<span class="text-sm">Drag images or upload</span>
						</div>
					</div>
				</div>

				<!-- Limit Slider -->
				<div class="space-y-3 pt-2">
					<div class="flex justify-between text-xs font-bold text-gray-500 uppercase">
						<span>Result Count</span>
						<span id="limit-val" class="text-brand-accent">4000</span>
					</div>
					<!-- 修正箇所: oninput属性を追加 -->
					<input type="range" id="search-limit" min="2000" max="50000" value="4000" step="2000"
						oninput="document.getElementById('limit-val').textContent = this.value"
						class="w-full h-1.5 bg-gray-800 rounded-lg appearance-none cursor-pointer accent-brand">
				</div>
			</div>

			<div class="p-5 border-t border-ui-border bg-black/40 shrink-0">
				<button onclick="searchManager.executeSearch()"
					class="w-full bg-brand hover:bg-brand-dark text-white font-bold py-3.5 rounded-xl transition-all shadow-lg active:scale-[0.98] flex items-center justify-center gap-2">
					<span>EXPLORE</span>
					<i class="fa-solid fa-arrow-right-long"></i>
				</button>
			</div>
		</div>
	</div>

	<!-- Detail View Modal -->
	<div id="detail-modal"
		class="hidden fixed inset-0 z-[60] bg-black flex flex-col animate-fade-in pointer-events-auto touch-none">

		<!-- Top Controls (Overlay) -->
		<div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-30 pointer-events-none">
			<div
				class="pointer-events-auto btn-glass px-4 py-3 rounded-full text-xs font-mono text-gray-300 flex items-center shadow-lg h-12">
				ID: <span id="detail-id" class="text-brand-accent font-bold ml-2"></span>
			</div>
			<button onclick="ui.closeDetailModal()"
				class="pointer-events-auto w-12 h-12 btn-glass rounded-full text-white flex items-center justify-center shadow-lg">
				<i class="fa-solid fa-xmark text-lg"></i>
			</button>
		</div>

		<!-- Interactive Image Area -->
		<div id="detail-view-container"
			class="w-full h-full relative overflow-hidden bg-black touch-none flex items-center justify-center">

			<div id="detail-image-wrapper"
				class="relative w-full h-full flex items-center justify-center will-change-transform origin-center">
				<img id="detail-image-thumb" src=""
					class="absolute max-w-full max-h-full object-contain pointer-events-none select-none transition-opacity duration-300 opacity-0 filter blur-sm">
				<img id="detail-image" src=""
					class="relative max-w-full max-h-full object-contain pointer-events-none select-none shadow-2xl transition-opacity duration-300 opacity-0">
			</div>

			<!-- Loader -->
			<div id="detail-loading" class="absolute inset-0 flex items-center justify-center pointer-events-none">
				<div class="loader"></div>
			</div>
		</div>

		<!-- Floating Action Menu (Press & Slide) -->
		<div id="fab-container"
			class="absolute bottom-8 right-6 z-40 pointer-events-auto flex flex-col items-end gap-3 select-none touch-none"
			oncontextmenu="return false;">

			<!-- Menu Items (Hidden by default) -->
			<!-- ここの padding-bottom (pb-4) はメニューとボタンの間隔なので維持 -->
			<div id="fab-menu"
				class="flex flex-col gap-3 items-end transition-all duration-200 opacity-0 translate-y-4 pointer-events-none scale-90 origin-bottom pb-4">

				<!-- Item 1: Use as Ref -->
				<!-- 修正: pr-1 を削除しました -->
				<div id="fab-opt-ref"
					class="group flex items-center gap-3 transition-transform duration-150 origin-right">
					<span
						class="bg-black/60 backdrop-blur text-white text-xs font-bold px-2 py-1 rounded opacity-0 group-[.active]:opacity-100 transition-opacity">Use
						as Ref</span>
					<div
						class="fab-btn w-14 h-14 rounded-full btn-glass text-white flex items-center justify-center shadow-lg text-xl group-[.active]:bg-brand group-[.active]:border-brand group-[.active]:scale-110 transition-all">
						<i class="fa-solid fa-layer-group"></i>
					</div>
				</div>

				<!-- Item 2: Tags -->
				<!-- 修正: pr-1 を削除しました -->
				<div id="fab-opt-tags"
					class="group flex items-center gap-3 transition-transform duration-150 origin-right">
					<span
						class="bg-black/60 backdrop-blur text-white text-xs font-bold px-2 py-1 rounded opacity-0 group-[.active]:opacity-100 transition-opacity">Tags</span>
					<div
						class="fab-btn w-14 h-14 rounded-full btn-glass text-white flex items-center justify-center shadow-lg text-xl group-[.active]:bg-brand group-[.active]:border-brand group-[.active]:scale-110 transition-all">
						<i class="fa-solid fa-tags"></i>
					</div>
				</div>

				<!-- Item 3: Close -->
				<!-- 修正: pr-1 を削除しました -->
				<div id="fab-opt-close"
					class="group flex items-center gap-3 transition-transform duration-150 origin-right">
					<span
						class="bg-black/60 backdrop-blur text-white text-xs font-bold px-2 py-1 rounded opacity-0 group-[.active]:opacity-100 transition-opacity">Close</span>
					<div
						class="fab-btn w-14 h-14 rounded-full btn-glass text-red-400 flex items-center justify-center shadow-lg text-xl group-[.active]:bg-red-500/80 group-[.active]:text-white group-[.active]:border-red-500 group-[.active]:scale-110 transition-all">
						<i class="fa-solid fa-xmark"></i>
					</div>
				</div>

			</div>

			<!-- Main Trigger Button -->
			<button id="fab-trigger"
				class="w-14 h-14 btn-glass rounded-full shadow-[0_0_20px_rgba(0,0,0,0.5)] flex items-center justify-center text-xl transition-transform active:scale-90 z-50">
				<i class="fa-solid fa-bars"></i>
			</button>
		</div>
	</div>

	<!-- Tags Bottom Sheet Modal -->
	<div id="tags-modal" class="hidden fixed inset-0 z-[70] pointer-events-auto">
		<!-- Backdrop -->
		<div class="absolute inset-0 bg-black/60 backdrop-blur-sm animate-fade-in" onclick="ui.closeTagsModal()"></div>

		<!-- Sheet -->
		<div
			class="absolute bottom-0 left-0 w-full max-h-[60vh] bg-ui-panel border-t border-ui-border rounded-t-3xl shadow-[0_-10px_40px_rgba(0,0,0,0.8)] flex flex-col animate-slide-in-bottom">
			<!-- Handle -->
			<div class="w-full flex justify-center pt-3 pb-1" onclick="ui.closeTagsModal()">
				<div class="w-12 h-1.5 bg-gray-700 rounded-full opacity-50"></div>
			</div>

			<div class="p-5 border-b border-ui-border flex justify-between items-center">
				<h3 class="text-sm font-bold text-gray-300 uppercase tracking-wider">
					<i class="fa-solid fa-tags mr-2 text-brand"></i>Detected Tags
				</h3>
				<button onclick="ui.closeTagsModal()" class="text-gray-500 hover:text-white p-2">
					<i class="fa-solid fa-chevron-down"></i>
				</button>
			</div>

			<div id="tags-list"
				class="flex-1 overflow-y-auto custom-scroll p-5 pb-10 flex flex-wrap content-start gap-2">
				<!-- Tags injected here -->
			</div>
		</div>
	</div>

	<!-- Notification Toast -->
	<div id="toast"
		class="fixed top-6 left-1/2 transform -translate-x-1/2 bg-ui-panel border border-ui-border text-white px-5 py-3 rounded-full shadow-2xl flex items-center gap-3 z-[100] transition-all duration-300 opacity-0 translate-y-[-20px] pointer-events-none scale-90">
		<i class="fa-solid fa-info-circle text-brand-accent"></i>
		<span id="toast-msg" class="text-sm font-medium">Notification</span>
	</div>

	<script>
		// --- Configuration ---
		const API_BASE = window.location.origin;
		// const API_BASE = "http://localhost:8002"; // Development override

		const CONFIG = {
			baseCellSize: 180,
			gap: 2,
			zoomMin: 0.3,
			zoomMax: 1.0,
			initialZoom: 0.6,
			renderBuffer: 1.5,
			thumbSize: '256x256' // Matches server-side optimization
		};

		// --- Core State ---
		const state = {
			images: [],
			camera: { x: 0, y: 0, z: CONFIG.initialZoom },
			drag: { active: false, lastX: 0, lastY: 0, startX: 0, startY: 0, startTime: 0 },
			searchRefs: [],
			currentId: null,
			canvasSize: { w: 0, h: 0 },

			// Detail View State
			detail: {
				x: 0, y: 0, scale: 1,
				isDragging: false,
				lastX: 0, lastY: 0,
				lastDist: 0,
				pointers: new Map()
			}
		};

		// --- Math & Spiral ---
		function getSpiralCoord(n) {
			if (n === 0) return { x: 0, y: 0 };
			const k = Math.ceil((Math.sqrt(n + 1) - 1) / 2);
			let t = 2 * k;
			let m = (t + 1) * (t + 1);
			if (n >= m - t) return { x: k - (m - n), y: -k };
			m -= t;
			if (n >= m - t) return { x: -k, y: -k + (m - n) };
			m -= t;
			if (n >= m - t) return { x: -k + (m - n), y: k };
			return { x: k, y: k - (m - n - t) };
		}

		// --- Gallery Canvas Engine ---
		const canvas = document.getElementById('galleryCanvas');
		const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });

		function initCanvas() {
			const dpr = window.devicePixelRatio || 1;
			const rect = canvas.parentElement.getBoundingClientRect();
			canvas.width = rect.width * dpr;
			canvas.height = rect.height * dpr;
			canvas.style.width = `${rect.width}px`;
			canvas.style.height = `${rect.height}px`;
			ctx.scale(dpr, dpr);
			state.canvasSize.w = rect.width;
			state.canvasSize.h = rect.height;
			ctx.imageSmoothingEnabled = true;
			ctx.imageSmoothingQuality = 'medium';
			render();
		}

		function render() {
			ctx.fillStyle = '#050505';
			ctx.fillRect(0, 0, state.canvasSize.w, state.canvasSize.h);

			const cellSize = CONFIG.baseCellSize;
			const fullSize = cellSize + CONFIG.gap;
			const zoom = state.camera.z;
			const hw = state.canvasSize.w / 2;
			const hh = state.canvasSize.h / 2;

			// Viewport bounds
			const visibleW = state.canvasSize.w / zoom;
			const visibleH = state.canvasSize.h / zoom;
			const margin = cellSize * CONFIG.renderBuffer;
			const left = state.camera.x - visibleW / 2 - margin;
			const right = state.camera.x + visibleW / 2 + margin;
			const top = state.camera.y - visibleH / 2 - margin;
			const bottom = state.camera.y + visibleH / 2 + margin;

			for (let i = 0; i < state.images.length; i++) {
				const imgData = state.images[i];
				const wx = imgData.gx * fullSize;
				const wy = imgData.gy * fullSize;

				// Culling
				if (wx + cellSize / 2 < left || wx - cellSize / 2 > right ||
					wy + cellSize / 2 < top || wy - cellSize / 2 > bottom) continue;

				const sx = (wx - state.camera.x) * zoom + hw;
				const sy = (wy - state.camera.y) * zoom + hh;
				const sSize = cellSize * zoom;

				// Draw Logic
				if (!imgData.loaded) {
					ctx.fillStyle = '#0f0f12';
					ctx.fillRect(sx - sSize / 2, sy - sSize / 2, sSize, sSize);

					if (!imgData.loading) {
						imgData.loading = true;
						const img = new Image();
						// Request optimized thumbnail
						img.src = `${API_BASE}/API/media/${imgData.id}?size=${CONFIG.thumbSize}`;
						img.onload = () => {
							imgData.imgObj = img;
							imgData.loaded = true;
							imgData.loading = false;
							requestAnimationFrame(render);
						};
						img.onerror = () => { imgData.loading = false; };
					}
					if (sSize > 40) {
						ctx.fillStyle = '#333';
						ctx.font = `bold ${10 * zoom}px monospace`;
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';
						ctx.fillText(imgData.id, sx, sy);
					}
				} else {
					const dx = sx - sSize / 2;
					const dy = sy - sSize / 2;
					const dSize = sSize;

					// No need for complex aspect ratio calc here
					// Draw entire source image into destination rect
					ctx.drawImage(imgData.imgObj, 0, 0, 256, 256, dx, dy, dSize, dSize);
				}
			}
		}

		// --- Interaction: Gallery (Fixed for Mouse & Touch) ---
		function setupGalleryInteractions() {
			// アクティブなポインター（押されている指/マウス）のみを保持する
			const pointers = new Map();

			// ジェスチャー計算用
			let prevDist = -1;
			let prevCenter = null;

			// クリック判定用
			let startPos = { x: 0, y: 0 };
			let totalMoveDistance = 0;
			let startTime = 0;

			// --- ヘルパー関数 ---
			function getDistance(p1, p2) {
				return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
			}

			function getCenter(p1, p2) {
				return {
					x: (p1.clientX + p2.clientX) / 2,
					y: (p1.clientY + p2.clientY) / 2
				};
			}

			// --- イベントハンドラー ---

			canvas.addEventListener('pointerdown', e => {
				// マウスの場合、左クリック(0)以外は無視（右クリメニューなどを妨害しない）
				if (e.pointerType === 'mouse' && e.button !== 0) return;

				pointers.set(e.pointerId, e);
				canvas.setPointerCapture(e.pointerId);

				// 最初の1本目の指/クリックの時だけ初期化
				if (pointers.size === 1) {
					startPos = { x: e.clientX, y: e.clientY };
					totalMoveDistance = 0;
					startTime = Date.now();

					// ジェスチャー開始位置として記録（パン操作の始点）
					prevCenter = { x: e.clientX, y: e.clientY };
				}

				// 2本目以降が追加されたら、距離計算などをリセットしてピンチに備える
				if (pointers.size === 2) {
					prevDist = -1;
					prevCenter = null;
				}
			});

			canvas.addEventListener('pointermove', e => {
				// 【重要】Mapに登録されていないポインター（ホバー中のマウスなど）は無視する
				if (!pointers.update_flag && !pointers.has(e.pointerId)) return;

				// イベント情報を最新に更新
				pointers.set(e.pointerId, e);

				// --- ケース1: ピンチズーム (2本指) ---
				if (pointers.size === 2) {
					const [p1, p2] = [...pointers.values()];
					const curDist = getDistance(p1, p2);
					const curCenter = getCenter(p1, p2);

					// 前回のフレーム情報がある場合のみ計算
					if (prevDist > 0 && prevCenter) {
						// ズーム率
						const scaleDiff = curDist / prevDist;
						let newZoom = state.camera.z * scaleDiff;
						newZoom = Math.max(CONFIG.zoomMin, Math.min(newZoom, CONFIG.zoomMax));

						// ピンチ中心を基準にズーム＆パン
						const hw = state.canvasSize.w / 2;
						const hh = state.canvasSize.h / 2;

						// 1. 前回の中心点に対応するワールド座標を計算
						const prevWx = (prevCenter.x - hw) / state.camera.z + state.camera.x;
						const prevWy = (prevCenter.y - hh) / state.camera.z + state.camera.y;

						// 2. カメラ更新
						state.camera.z = newZoom;
						state.camera.x = prevWx - (curCenter.x - hw) / newZoom;
						state.camera.y = prevWy - (curCenter.y - hh) / newZoom;

						requestAnimationFrame(render);
					}

					prevDist = curDist;
					prevCenter = curCenter;
					totalMoveDistance += 10; // ピンチ中はクリック判定を無効化
				}
				// --- ケース2: パン移動 (1本指 / マウスドラッグ) ---
				else if (pointers.size === 1) {
					// 指が1本だけ、かつ前回位置が記録されている場合
					if (prevCenter) {
						const dx = e.clientX - prevCenter.x;
						const dy = e.clientY - prevCenter.y;

						state.camera.x -= dx / state.camera.z;
						state.camera.y -= dy / state.camera.z;

						totalMoveDistance += Math.hypot(dx, dy);
						requestAnimationFrame(render);
					}

					// 現在位置を次回の「前回位置」として保存
					prevCenter = { x: e.clientX, y: e.clientY };
				}
			});

			// ポインター終了処理
			const pointerUpHandler = e => {
				if (!pointers.has(e.pointerId)) return;

				pointers.delete(e.pointerId);
				canvas.releasePointerCapture(e.pointerId);

				// 指が減ったのでジェスチャー状態をリセット
				prevDist = -1;
				prevCenter = null;

				// もし指がまだ残っているなら（例: 2本→1本）、残った指の位置を次回の始点にする
				if (pointers.size === 1) {
					const remaining = [...pointers.values()][0];
					prevCenter = { x: remaining.clientX, y: remaining.clientY };
				}

				// 全ての指が離れた時、クリック判定を行う
				if (pointers.size === 0) {
					const timeDiff = Date.now() - startTime;
					// 移動が少なく、短時間だった場合のみクリックとみなす
					if (totalMoveDistance < 10 && timeDiff < 300) {
						handleClick(e.clientX, e.clientY);
					}
				}
			};

			canvas.addEventListener('pointerup', pointerUpHandler);
			canvas.addEventListener('pointercancel', pointerUpHandler);
			canvas.addEventListener('pointerout', pointerUpHandler);
			canvas.addEventListener('pointerleave', pointerUpHandler);

			// --- マウスホイール (PC用ズーム) ---
			canvas.addEventListener('wheel', e => {
				e.preventDefault();
				const delta = -e.deltaY * 0.001;
				const factor = Math.pow(10, delta);
				let newZoom = Math.max(CONFIG.zoomMin, Math.min(state.camera.z * factor, CONFIG.zoomMax));

				const hw = state.canvasSize.w / 2;
				const hh = state.canvasSize.h / 2;

				const wx = (e.clientX - hw) / state.camera.z + state.camera.x;
				const wy = (e.clientY - hh) / state.camera.z + state.camera.y;

				state.camera.z = newZoom;
				state.camera.x = wx - (e.clientX - hw) / newZoom;
				state.camera.y = wy - (e.clientY - hh) / newZoom;

				requestAnimationFrame(render);
			}, { passive: false });
		}
		function handleClick(sx, sy) {
			const hw = state.canvasSize.w / 2;
			const hh = state.canvasSize.h / 2;
			const wx = (sx - hw) / state.camera.z + state.camera.x;
			const wy = (sy - hh) / state.camera.z + state.camera.y;
			const half = CONFIG.baseCellSize / 2;
			const full = CONFIG.baseCellSize + CONFIG.gap;

			for (const img of state.images) {
				const ix = img.gx * full;
				const iy = img.gy * full;
				if (wx >= ix - half && wx <= ix + half && wy >= iy - half && wy <= iy + half) {
					ui.openDetailModal(img.id);
					break;
				}
			}
		}

		// --- Interaction: Detail View (True Pinch-Zoom, Wheel & Backdrop Close) ---
		function setupDetailInteractions() {
			const container = document.getElementById('detail-view-container');
			const wrapper = document.getElementById('detail-image-wrapper');

			// 現在の変形状態
			let transform = { x: 0, y: 0, scale: 1 };

			// ジェスチャー・マウス操作用の状態
			let evCache = [];
			let startState = {
				scale: 1,
				x: 0, y: 0,
				dist: 0,
				midX: 0, midY: 0
			};

			// ドラッグ・クリック判定用フラグ
			let hasMoved = false;

			// 画面更新関数
			function updateElement(duration = 0) {
				wrapper.style.transition = duration > 0 ? `transform ${duration}ms cubic-bezier(0.1, 0.9, 0.2, 1)` : '';
				wrapper.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`;
			}

			// --- 1. ポインターイベント (タッチ & マウスドラッグ) ---

			container.addEventListener('pointerdown', e => {
				// マウスの場合、左ボタン以外は無視
				if (e.pointerType === 'mouse' && e.button !== 0) return;

				container.setPointerCapture(e.pointerId);
				evCache.push(e);
				hasMoved = false;

				if (evCache.length === 1) {
					// 移動開始
					startState.x = transform.x;
					startState.y = transform.y;
					startState.midX = e.clientX;
					startState.midY = e.clientY;
				} else if (evCache.length === 2) {
					// ピンチ開始 (2本指)
					startState.scale = transform.scale;
					startState.x = transform.x;
					startState.y = transform.y;

					const dx = evCache[1].clientX - evCache[0].clientX;
					const dy = evCache[1].clientY - evCache[0].clientY;
					startState.dist = Math.hypot(dx, dy);

					startState.midX = (evCache[0].clientX + evCache[1].clientX) / 2;
					startState.midY = (evCache[0].clientY + evCache[1].clientY) / 2;
				}
			});

			container.addEventListener('pointermove', e => {
				const idx = evCache.findIndex(c => c.pointerId === e.pointerId);
				if (idx > -1) evCache[idx] = e;
				else return; // キャッシュにないポインタは無視

				// 動きの検出 (クリック誤爆防止)
				if (!hasMoved) {
					// 単純な移動量チェック
					const dx = e.clientX - startState.midX;
					const dy = e.clientY - startState.midY;
					// 2本指の場合は即座に動いたとみなす
					if (evCache.length > 1 || Math.hypot(dx, dy) > 5) {
						hasMoved = true;
					}
				}

				if (evCache.length === 2) {
					// --- 2本指: ピンチズーム ---
					const dx = evCache[1].clientX - evCache[0].clientX;
					const dy = evCache[1].clientY - evCache[0].clientY;
					const newDist = Math.hypot(dx, dy);
					const newMidX = (evCache[0].clientX + evCache[1].clientX) / 2;
					const newMidY = (evCache[0].clientY + evCache[1].clientY) / 2;

					if (startState.dist < 10) return;

					const zoomRatio = newDist / startState.dist;
					let newScale = startState.scale * zoomRatio;
					newScale = Math.max(0.5, Math.min(newScale, 5.0));

					const effectiveRatio = newScale / startState.scale;

					// 座標補正ロジック
					const rect = container.getBoundingClientRect();
					const cx = rect.left + rect.width / 2;
					const cy = rect.top + rect.height / 2;

					// 画像中心から見たタッチ中心のベクトル
					// (startState.x/y は transform値 = 画像中心のズレ)
					const vecX = startState.midX - (cx + startState.x);
					const vecY = startState.midY - (cy + startState.y);

					const moveX = newMidX - startState.midX;
					const moveY = newMidY - startState.midY;

					transform.scale = newScale;
					transform.x = startState.x + moveX - (vecX * effectiveRatio - vecX);
					transform.y = startState.y + moveY - (vecY * effectiveRatio - vecY);

					updateElement();

				} else if (evCache.length === 1) {
					// --- 1本指: パン ---
					// マウスドラッグ or 拡大中のタッチ移動
					// (拡大していないときは移動させない = スワイプで閉じるUI等のため。ここでは単純化)
					if (transform.scale > 1.0 || e.pointerType === 'mouse') {
						const dx = e.clientX - startState.midX;
						const dy = e.clientY - startState.midY;
						transform.x = startState.x + dx;
						transform.y = startState.y + dy;
						updateElement();
					}
				}
			});

			const endGesture = (e) => {
				const idx = evCache.findIndex(c => c.pointerId === e.pointerId);
				if (idx > -1) {
					evCache.splice(idx, 1);
					container.releasePointerCapture(e.pointerId);
				}

				// 指が残っている場合のリセット
				if (evCache.length === 1) {
					startState.x = transform.x;
					startState.y = transform.y;
					startState.midX = evCache[0].clientX;
					startState.midY = evCache[0].clientY;
				}

				if (evCache.length === 0) {
					snapBack();
				}
			};

			container.addEventListener('pointerup', endGesture);
			container.addEventListener('pointercancel', endGesture);
			container.addEventListener('pointerleave', endGesture);


			// --- 2. マウスホイール (ここが追加された機能です) ---

			container.addEventListener('wheel', e => {
				e.preventDefault();

				// ホイールの感度調整
				const delta = -e.deltaY * 0.001;
				const factor = Math.pow(10, delta);

				let newScale = transform.scale * factor;
				newScale = Math.max(0.5, Math.min(newScale, 5.0));

				// 実際の倍率変化
				const effectiveFactor = newScale / transform.scale;

				// マウス位置に向かってズームする計算
				const rect = container.getBoundingClientRect();
				// コンテナ中心座標
				const cx = rect.width / 2;
				const cy = rect.height / 2;

				// マウス位置 (コンテナ左上基準)
				const mx = e.clientX - rect.left;
				const my = e.clientY - rect.top;

				// マウス位置の「コンテナ中心からの」オフセット
				const dx = mx - cx;
				const dy = my - cy;

				/* 
				   計算式:
				   新しい位置 = 現在の位置 - (マウス位置 - 現在の画像中心) * (倍率 - 1)
				   (マウス位置の下にある画像の点が、ズーム後も同じマウス位置に来るように移動する)
				*/
				transform.x -= (dx - transform.x) * (effectiveFactor - 1);
				transform.y -= (dy - transform.y) * (effectiveFactor - 1);
				transform.scale = newScale;

				updateElement();

				// ホイール操作が止まったらスナップバック判定するためにデバウンス実行
				clearTimeout(window.wheelSnapTimer);
				window.wheelSnapTimer = setTimeout(snapBack, 300);

			}, { passive: false });


			// --- 3. 境界チェック (スナップバック) ---
			function snapBack() {
				let corrected = false;
				const rect = container.getBoundingClientRect();

				if (transform.scale < 1) {
					// 1倍未満ならリセット
					transform.scale = 1;
					transform.x = 0;
					transform.y = 0;
					corrected = true;
				} else {
					// はみ出し制限
					const w = rect.width * transform.scale;
					const h = rect.height * transform.scale;
					const maxX = (w - rect.width) / 2;
					const maxY = (h - rect.height) / 2;

					if (transform.x > maxX) { transform.x = maxX; corrected = true; }
					else if (transform.x < -maxX) { transform.x = -maxX; corrected = true; }

					if (transform.y > maxY) { transform.y = maxY; corrected = true; }
					else if (transform.y < -maxY) { transform.y = -maxY; corrected = true; }
				}

				if (corrected) {
					updateElement(300);
				}
			}


			// --- 4. クリック処理 (背景クリック & ダブルクリック) ---
			let lastTap = 0;
			container.addEventListener('click', (e) => {
				// ドラッグしていた場合はクリックとみなさない
				if (hasMoved) return;

				const now = Date.now();

				// ダブルクリック判定 (リセット)
				if (now - lastTap < 300) {
					transform = { x: 0, y: 0, scale: 1 };
					updateElement(300);
					lastTap = 0;
					return;
				}
				lastTap = now;

				// 背景クリック判定 (画像の範囲外なら閉じる)
				const imgElement = document.getElementById('detail-image');
				const imgRect = imgElement.getBoundingClientRect();

				if (imgRect.width > 0 && imgRect.height > 0) {
					const isInside = (
						e.clientX >= imgRect.left &&
						e.clientX <= imgRect.right &&
						e.clientY >= imgRect.top &&
						e.clientY <= imgRect.bottom
					);

					if (!isInside) {
						ui.closeDetailModal();
					}
				}
			});

			// 外部からのリセット用
			state.detail.reset = () => {
				transform = { x: 0, y: 0, scale: 1 };
				updateElement();
			};
		}

		// --- API & Search ---
		const api = {
			async search(query, limit) {
				const fd = new FormData();
				if (query.text) fd.append('q', query.text);
				fd.append('limit', limit);
				query.images.forEach(ref => {
					fd.append('image', ref.blob, 'ref.jpg');
					fd.append('image_weight', ref.weight);
				});
				try {
					const res = await fetch(`${API_BASE}/API/search`, { method: 'POST', body: fd });
					return await res.json();
				} catch { return []; }
			},
			async getTags(id) {
				try {
					const res = await fetch(`${API_BASE}/API/tags_from_id/${id}`);
					return await res.json();
				} catch { return []; }
			},
			async getTagSuggestions(prefix) {
				try {
					const res = await fetch(`${API_BASE}/API/tags?prefix=${encodeURIComponent(prefix)}`);
					// Backend returns list of [name, category, count]
					return await res.json();
				} catch { return []; }
			},
			async getBlob(id) {
				const res = await fetch(`${API_BASE}/API/media/${id}`);
				return await res.blob();
			}
		};

		const searchManager = {
			addRef(blob, weight = 1.0) {
				state.searchRefs.push({ blob, weight, url: URL.createObjectURL(blob) });
				this.renderRefs();
			},
			removeRef(idx) {
				state.searchRefs.splice(idx, 1);
				this.renderRefs();
			},
			handleFileUpload(input) {
				if (input.files) Array.from(input.files).forEach(f => this.addRef(f));
				input.value = '';
			},
			renderRefs() {
				const c = document.getElementById('reference-list');
				const empty = document.getElementById('empty-refs');
				while (c.children.length > 1) { c.removeChild(c.lastChild); }
				if (state.searchRefs.length === 0) {
					empty.classList.remove('hidden'); empty.classList.add('flex');
				} else {
					empty.classList.add('hidden'); empty.classList.remove('flex');
					state.searchRefs.forEach((ref, i) => {
						const el = document.createElement('div');
						el.className = 'bg-black/40 p-3 rounded-xl border border-ui-border flex gap-3 animate-fade-in items-center';
						el.innerHTML = `
                            <img src="${ref.url}" class="w-14 h-14 object-cover rounded-lg bg-gray-800 shrink-0">
                            <div class="flex-1 min-w-0">
                                <input type="range" min="-1" max="1" step="0.1" value="${ref.weight}" 
                                    class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-brand"
                                    oninput="state.searchRefs[${i}].weight = this.value; this.nextElementSibling.innerText = this.value">
                                <div class="text-[10px] text-gray-500 font-bold mt-1 text-right">${ref.weight}</div>
                            </div>
                            <button onclick="searchManager.removeRef(${i})" class="text-gray-500 hover:text-red-400 p-2"><i class="fa-solid fa-trash-can"></i></button>
                        `;
						c.appendChild(el);
					});
				}
			},
			executeSearch() {
				ui.closeSearchModal();
				ui.setStatus('Searching...');
				const text = document.getElementById('search-text').value;
				const limit = document.getElementById('search-limit').value;

				// Hide suggestions immediately
				document.getElementById('search-suggestions').classList.add('hidden');

				api.search({ text, images: state.searchRefs }, limit).then(results => {
					state.images = results.map((entry, idx) => {
						const c = getSpiralCoord(idx);
						return { id: entry.id || entry, gx: c.x, gy: c.y, loaded: false, loading: false };
					});
					ui.setStatus(`${results.length} RESULTS`);
					app.resetView();
				});
			},
			addTagToSearch(tag) {
				const input = document.getElementById('search-text');
				const current = input.value.trim();
				// Prevent simple duplicates
				if (!current.includes(tag)) {
					input.value = current ? `${current} ${tag}` : tag;
				}
				ui.closeTagsModal();
				ui.closeDetailModal();
				ui.openSearchModal();
			},

			// Autocomplete Logic
			setupAutocomplete() {
				const input = document.getElementById('search-text');
				const suggestionsBox = document.getElementById('search-suggestions');
				let debounceTimer;

				input.addEventListener('input', (e) => {
					clearTimeout(debounceTimer);
					const val = input.value;

					// Get the last word (space separated)
					const words = val.split(' ');
					const lastWord = words[words.length - 1];

					if (lastWord.length < 2) {
						suggestionsBox.classList.add('hidden');
						return;
					}

					debounceTimer = setTimeout(async () => {
						const tags = await api.getTagSuggestions(lastWord);

						if (tags.length === 0) {
							suggestionsBox.classList.add('hidden');
							return;
						}

						suggestionsBox.innerHTML = '';
						tags.forEach(tagData => {
							// tagData is [name, category, count]
							const tagName = tagData[0];
							const count = tagData[2];

							const item = document.createElement('div');
							item.className = 'px-4 py-3 hover:bg-white/10 cursor-pointer flex justify-between items-center border-b border-white/5 last:border-0';
							item.innerHTML = `
								<span class="text-gray-200 font-medium">${tagName}</span>
								<span class="text-xs text-gray-500 bg-black/30 px-2 py-0.5 rounded-full">${count}</span>
							`;

							item.onclick = () => {
								words[words.length - 1] = tagName;
								input.value = words.join(' ') + ' ';
								suggestionsBox.classList.add('hidden');
								input.focus();
							};

							suggestionsBox.appendChild(item);
						});
						suggestionsBox.classList.remove('hidden');
					}, 200);
				});

				// Hide on blur (delayed to allow click)
				input.addEventListener('blur', () => {
					setTimeout(() => suggestionsBox.classList.add('hidden'), 200);
				});
			}
		};

		const ui = {
			openSearchModal: () => {
				document.getElementById('search-modal').classList.remove('hidden');
				// Focus input slightly delayed for mobile keyboard
				setTimeout(() => document.getElementById('search-text').focus(), 100);
			},
			closeSearchModal: () => document.getElementById('search-modal').classList.add('hidden'),

			openDetailModal: (id) => {
				state.currentId = id;
				const m = document.getElementById('detail-modal');
				const img = document.getElementById('detail-image');
				const thumb = document.getElementById('detail-image-thumb');
				const loader = document.getElementById('detail-loading');
				const wrapper = document.getElementById('detail-image-wrapper');

				// wrapperのスタイルを直接初期化
				wrapper.style.transition = 'none';
				wrapper.style.transform = 'translate(0px, 0px) scale(1)';

				// ジェスチャー状態のリセット
				if (state.detail.reset) state.detail.reset();

				m.classList.remove('hidden');
				document.getElementById('detail-id').innerText = id;

				loader.classList.remove('hidden');
				img.classList.add('opacity-0');
				thumb.classList.remove('opacity-0');

				thumb.src = `${API_BASE}/API/media/${id}?size=${CONFIG.thumbSize}`;

				const hiRes = new Image();
				hiRes.src = `${API_BASE}/API/media/${id}`;
				hiRes.onload = () => {
					img.src = hiRes.src;
					img.classList.remove('opacity-0');
					thumb.classList.add('opacity-0');
					loader.classList.add('hidden');
				};
			},
			closeDetailModal: () => {
				document.getElementById('detail-modal').classList.add('hidden');
				ui.closeTagsModal();
			},

			async openTagsModal() {
				if (!state.currentId) return;
				const m = document.getElementById('tags-modal');
				const list = document.getElementById('tags-list');
				m.classList.remove('hidden');

				list.innerHTML = '<div class="w-full text-center py-4"><div class="loader mx-auto"></div></div>';

				try {
					const tags = await api.getTags(state.currentId);
					list.innerHTML = '';
					if (tags.length === 0) list.innerHTML = '<div class="text-gray-500 w-full text-center py-4">No tags detected</div>';

					tags.forEach(t => {
						const el = document.createElement('button'); // Changed div to button

						// Green(120) to Red(0) based on probability (1.0 -> 0.0)
						// Clamp between 0 and 120 just in case
						const hue = Math.max(0, Math.min(120, Math.round(t.probability * 120)));

						const pct = Math.round(t.probability * 100);
						el.className = 'px-3 py-1.5 rounded-lg text-sm flex items-center gap-2 hover:scale-105 active:scale-95 transition-all border';

						// Dynamic HSL coloring
						// Color: Lightness 70%, Border: Lightness 30%, Bg: Alpha 0.2
						el.style.cssText = `
							background: hsla(${hue}, 70%, 20%, 0.4);
							border-color: hsla(${hue}, 70%, 40%, 0.5);
							color: hsl(${hue}, 80%, 85%);
						`;

						el.innerHTML = `<span class="font-medium">${t.tag_name}</span><span class="font-mono text-xs opacity-70">${pct}%</span>`;

						// Click to add tag to search
						el.onclick = () => searchManager.addTagToSearch(t.tag_name);

						list.appendChild(el);
					});
				} catch {
					list.innerHTML = '<div class="text-red-400">Failed to load tags</div>';
				}
			},
			closeTagsModal: () => document.getElementById('tags-modal').classList.add('hidden'),

			addCurrentToSearch: async () => {
				if (!state.currentId) return;
				ui.toast('Downloading...');
				try {
					const blob = await api.getBlob(state.currentId);
					searchManager.addRef(blob);
					ui.closeDetailModal();
					ui.openSearchModal();
					ui.toast('Added to search');
				} catch { ui.toast('Download failed', true); }
			},

			setStatus: (msg) => document.getElementById('status-indicator').innerText = msg.toUpperCase(),
			toast: (msg, error = false) => {
				const t = document.getElementById('toast');
				document.getElementById('toast-msg').innerText = msg;
				t.querySelector('i').className = error ? 'fa-solid fa-triangle-exclamation text-red-500' : 'fa-solid fa-circle-check text-green-400';
				t.classList.remove('opacity-0', 'translate-y-[-20px]', 'scale-90');
				setTimeout(() => t.classList.add('opacity-0', 'translate-y-[-20px]', 'scale-90'), 2500);
			}
		};

		const app = {
			resetView: () => {
				state.camera = { x: 0, y: 0, z: CONFIG.initialZoom };
				render();
			}
		};

		function setupFabInteractions() {
			const trigger = document.getElementById('fab-trigger');
			const menu = document.getElementById('fab-menu');
			const optRef = document.getElementById('fab-opt-ref');
			const optTags = document.getElementById('fab-opt-tags');
			const optClose = document.getElementById('fab-opt-close');

			const options = [
				{ el: optRef, action: () => ui.addCurrentToSearch() },
				{ el: optTags, action: () => ui.openTagsModal() },
				{ el: optClose, action: () => ui.closeDetailModal() }
			];

			let longPressTimer = null;
			let isMenuOpen = false;
			let activeOption = null;
			let rects = []; // 当たり判定用キャッシュ

			// メニューを開く処理
			const openMenu = () => {
				isMenuOpen = true;
				menu.classList.remove('opacity-0', 'translate-y-4', 'pointer-events-none', 'scale-90');
				trigger.classList.add('scale-75', 'opacity-50'); // トリガーを目立たなくする

				// バイブレーション（70ms）
				if (navigator.vibrate) {
					try { navigator.vibrate(70); } catch (e) { }
				}

				// 各オプションの当たり判定矩形を保存
				rects = options.map(opt => ({
					item: opt,
					rect: opt.el.getBoundingClientRect()
				}));
			};

			// メニューを閉じる・リセット処理
			const closeMenu = () => {
				isMenuOpen = false;
				activeOption = null;

				menu.classList.add('opacity-0', 'translate-y-4', 'pointer-events-none', 'scale-90');
				trigger.classList.remove('scale-75', 'opacity-50');

				// 選択状態の解除
				options.forEach(o => o.el.classList.remove('active'));
			};

			// --- イベントハンドラ ---

			trigger.addEventListener('pointerdown', (e) => {
				trigger.setPointerCapture(e.pointerId);

				// 長押しタイマー開始 (200ms)
				longPressTimer = setTimeout(() => {
					openMenu();
				}, 200);
			});

			trigger.addEventListener('pointermove', (e) => {
				// メニューが開いていないときは何もしない
				if (!isMenuOpen) return;

				// 指の位置にある要素を判定
				const x = e.clientX;
				const y = e.clientY;

				let found = null;

				// キャッシュした矩形で当たり判定（指の下にあるか）
				for (const data of rects) {
					const r = data.rect;
					// ヒットエリアを少し広めにとる (+20px)
					if (x >= r.left - 20 && x <= r.right + 20 && y >= r.top - 10 && y <= r.bottom + 10) {
						found = data.item;
						break;
					}
				}

				if (activeOption !== found) {
					// 状態が変わった時だけDOM操作
					if (activeOption) activeOption.el.classList.remove('active');
					if (found) {
						found.el.classList.add('active');
						// 項目選択時にも短いバイブレーション (15ms)
						if (navigator.vibrate) {
							try { navigator.vibrate(15); } catch (e) { }
						}
					}
					activeOption = found;
				}
			});

			const endInteraction = (e) => {
				clearTimeout(longPressTimer);
				trigger.releasePointerCapture(e.pointerId);

				if (isMenuOpen) {
					// メニューが開いていて、どこかのオプションを選択中なら実行
					if (activeOption) {
						activeOption.action();
					}
					closeMenu();
				} else {
					// 短押し時の挙動：
					// 何もしないか、トグルするか。
					// 現在の要件では「押したままスライド」がメインのため、
					// 短押しで「閉じる」アクションを実行するか、何もしないのが一般的。
					// 誤操作防止のため何もしません。
				}
			};

			trigger.addEventListener('pointerup', endInteraction);
			trigger.addEventListener('pointercancel', (e) => {
				clearTimeout(longPressTimer);
				closeMenu();
			});

			// コンテキストメニュー（右クリックなど）を無効化
			trigger.addEventListener('contextmenu', e => e.preventDefault());
		}
		window.addEventListener('resize', initCanvas);
		window.addEventListener('load', () => {
			initCanvas();
			setupGalleryInteractions();
			setupDetailInteractions();
			setupFabInteractions();
			searchManager.setupAutocomplete(); // Initialize autocomplete
			searchManager.executeSearch();
		});
	</script>
</body>

</html>